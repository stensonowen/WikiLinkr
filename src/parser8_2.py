#Add argparse
#Add functionality to split into parts

import datetime, sys, os, re
import argparse, multiprocessing

def get_contents(text, start, end):
    #lazy man's regex: retrieve text from a certain context
    #returns empty string if context absent or start == end
    #args: text to search in, beginning of context, end of context
    try:
        a = text.index(start)
        b = text.index(end, a)  #only look for end index after start index
    except ValueError:
        return ""
    else:
        return text[a+len(start):b]

def parse_page(page_text):
    #match = re.search("<title>.+</title>", text)
    #title = match.group(0)[7:-8]
    title = get_contents(page_text, "<title>", "</title>")
    #write to error log if title == ""?
    #hash = get_contents(page_text, "<sha1>", "</sha1>")
    output = "<page>\n" + title.upper() + "\n"
    #output += hash + "\n"
    #links = set(re.findall("\[\[[^]^\n]+\]\]", page_text))
    links = set(re.findall("\[\[[^]\n]+]]", page_text))
    output += str(len(links)) + '\n'
    for link in links:
        link = link[2:-2].upper()
        if "|" in link:
            link = link[:link.index("|")]
        output += link + "\n"
    return output

def create_output_file(input_file):
    #seems to be buggy; probably just an absolute/relative path thing?
    n = 0
    shell = input_file + "_out%d"
    while os.path.isfile(shell % n):
        n += 1
    return (shell % n)

def conjoin(fn, n):
    res = fn + '_' + str(n)
    return res

def main():
    #set up parser 
    parser = argparse.ArgumentParser(description="Parse Wikipedia dump into its link structure")
    parser.add_argument('input', type=str, help="The dump, probably called 'x-y-pages-articles.xml' and found at dumps.wikimedia.org/backup-index.html")
    parser.add_argument('-o', '--output', type=str, action='store', help="Output file; name will be autogenerated if argument omitted")
    parser.add_argument('-n', '--num_parts', type=int, action='store', default=multiprocessing.cpu_count(), help="Number of files to split output into; default is the number of cores on this machine")
    args = vars(parser.parse_args())

    start_time = datetime.datetime.now()

    #generate output filename if necessary
    if args["output"] is None:
        output_master = create_output_file(args["input"])
    else:
        output_master = args["output"]
    print output_master
    #prep to break file up
    f_in = open(args["input"], 'r')
    f_in.seek(0, os.SEEK_END)
    length = f_in.tell()
    f_in.seek(0)
    min_length = length/args["num_parts"]
    #file_lengths = [0]*args["num_parts"]
    file_lengths = []
    files = []
    output_num = 0

    output_n = open(conjoin(output_master, output_num), 'w')
    print "\t" + output_n.name
    #output_n = open(output_master + '_' + str(output_num), 'w')
    #output = open(output_file, "w")
    #output.write(' '*10 + '\n')	#to be replaced by page count
    links = []
    parsed = 0
    page = ""
    for line in f_in:
        line = line.replace('\r', '')
        page += line
        if "</page>" in line:
            output_n.write(parse_page(page))
            page = ""
            parsed += 1
            #page completed; should check for new output
            if f_in.tell() - sum(file_lengths) > min_length:
                file_lengths.append(f_in.tell() - sum(file_lengths))
                files.append(conjoin(output_master,output_num))
                #file_lengths[output_num] = f_in.tell() - sum(file_lengths)
                output_num += 1
                output_n.close()
                output_n = open(conjoin(output_master,output_num), 'w')
                print "\t" + output_n.name

    output_n.close()
    output = open(output_master, 'w')
    output.write(str(parsed) + '\n')
    output.write('\n'.join(os.path.abspath(f) for f in files+[output_n.name]) + '\n')
    output.close()
    #prepend page count (overwrite blank line)
    #output.seek(0)
    #output.write(str(parsed))
    #output.close()


    elapsed_time = datetime.datetime.now() - start_time
    print parsed, "articles"
    print "just read from: \t", args["input"]
    print " and wrote to: \t ", output_master
    print elapsed_time
    print elapsed_time.seconds, "seconds"

if __name__ == "__main__":
    main()
